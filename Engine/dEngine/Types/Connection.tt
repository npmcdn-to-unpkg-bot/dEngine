<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#  const int maxParametersCount = 7; #>
// <auto-generated>
// This code was generated by Connection.tt
// <#= DateTime.Now.ToString("R") #>
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// </auto-generated>

using System;
using Dynamitey;

namespace dEngine
{
	using Services;

	/// <summary>
	/// An object with represents the connection between a listener and a signal.
	/// </summary>
	public sealed class Connection
	{
		private readonly Signal _signal;
		private readonly LuaAction _action;

		internal Connection(Signal signal, LuaAction action)
		{
			_signal = signal;
			_action = action;
		}
		
		/// <summary>
		/// Invokes the listener.
		/// </summary>
		public void Invoke()
		{
			_action.Invoke();
		}
		
		/// <summary>
		/// Disconnects the listener from the signal.
		/// </summary>
		public bool disconnect()
		{	
			lock(_signal.Locker)
			{
				return _signal.Connections.Remove(this);
			}
		}
	}

<# for(int parametersCount = 1; parametersCount <= maxParametersCount; parametersCount++) {
   string parameters = String.Join(", ", Enumerable.Range(1, parametersCount).Select(i => "T" + i));
   string arguments = String.Join(", ", Enumerable.Range(1, parametersCount).Select(i => "T" + i +" arg" + i + " = default(T" + i + ")"));
   string argumentsCall = String.Join(", ", Enumerable.Range(1, parametersCount).Select(i => "arg" + i));
   string dynamicParamaters = String.Join(", ", Enumerable.Range(1, parametersCount).Select(i => "dynamic"));
#>

	/// <summary>
	/// An object with represents the connection between a listener and a signal.
	/// </summary>
	public sealed class Connection<<#= parameters #>>
	{
		private readonly Signal<<#= parameters #>> _signal;
		private readonly LuaAction<<#= parameters #>> _action;

		internal Connection(Signal<<#= parameters #>> signal, LuaAction<<#= parameters #>> action)
		{
			_signal = signal;
			_action = action;
		}
		
		/// <summary>
		/// Invokes the listener.
		/// </summary>
		public void Invoke(<#= arguments #>)
		{
			try
			{
				_action.Invoke(<#= argumentsCall #>);
			}
			catch(Exception e)
			{
				// HACK: gets the LuaTable from target locals - unsure how reliable this is. Alternative is to add LuaExceptionData check in HandeScriptException
				//var script = _func.Target.Locals[0].Value["script"];
				var script = ScriptService.CurrentScript;
				
				ScriptService.HandleException(e, script.InstanceId);
			}
		}
		
		/// <summary>
		/// Disconnects the listener from the signal.
		/// </summary>
		public bool disconnect()
		{
			lock(_signal.Locker)
			{
				return _signal.Connections.Remove(this);
			}
		}
	}
<#}#>
}
